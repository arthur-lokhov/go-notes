# Garbage Collector в Go

## Основные принципы работы

!!! info

    Сборщик мусора в Go — это неблокирующий, параллельный, трехцветный маркировочный алгоритм с конкурентной очисткой памяти.

### Ключевые характеристики

- **Неблокирующий**: Основная работа происходит параллельно с выполнением программы
- **Трехцветная маркировка**: Использует систему белый/серый/черный для отслеживания объектов
- **Поколенческий**: Оптимизирован для работы с короткоживущими объектами
- **Конкурентный**: Большая часть работы выполняется параллельно с программой

### Как работает GC в Go

1. **Маркировка(Mark)**: Обход всех достижимых объектов (начиная с корневых указателей). Помечает живые объекты (белый → серый → черный).
2. **Очистка(Sweep)**: Освобождает память, занятую неотмеченными объектами. Возвращает память в кучу для повторного использования.
3. **Сжатие(не всегда)**: В некоторых случаях уплотняет память для уменьшения фрагментации.

## Что такое Трехцветная маркировка

!!! info

    Трехцветная маркировка — это ключевой алгоритм, используемый в сборщике мусора Go для идентификации достижимых (живых) и недостижимых (мертвых) объектов в памяти.

### Цветовые маркеры и их значение

#### Белый (White)

1. **Статус**: Исходное состояние всех объектов.
2. **Значение**: Объект пока не обработан GC и считается потенциально мусором.
3. **Действие GC**: Если объект остался белым после фазы маркировки — он будет удален.

```go
// Все объекты начинают как "белые"
obj := &Object{} // Белый объект
```

#### Серый (Gray)

1. **Статус**: Объект обнаружен как достижимый, но его ссылки еще не проверены.
2. **Значение**: Объект точно жив, но GC еще не проверил что он ссылается на другие объекты.
3. **Действие GC**: Объект помещается в очередь для дальнейшего анализа.

```go
// Когда GC находит ссылку на объект:
obj.markGrey() // Теперь серый
```

#### Черный (Black)

1. **Статус**: Объект обработан полностью.
2. **Значение**: Объект жив и все его ссылки проверены.
3. **Действие GC**: Больше не будет сканироваться в текущем цикле GC.

```go
// После проверки всех ссылок объекта:
obj.markBlack() // Теперь черный
```

## Управление GC

### Переменные окружения для настройки

#### GOGC

```bash
GOGC=100 # процент роста кучи перед запуском GC (по умолчанию 100)
GOGC=off # полное отключение GC (не рекомендуется)
```

#### GODEBUG

```bash
GODEBUG=gctrace=1 # вывод трассировки работы GC
```

Пример вывода трасировки:

```bash
gc 8 @0.123s 1%: 0.015+0.45+0.023 ms clock, 0.12+0.56/0.89/0.067+0.18 ms cpu, 4->4->1 MB, 5 MB goal, 8 P
```

Где:

- `8` — номер сборки
- `@0.123s` — время работы программы
- `1%` — процент времени CPU на GC
- `4->4->1 MB` — размер кучи до/после/живых объектов

## Оптимизация работы с GC

### Уменьшение количества аллокаций

```go
// Плохо
func concat(a, b string) string {
    return a + b // Создает новую строку
}

// Лучше
func concat(a, b string, buf []byte) string {
    buf = buf[:0]
    buf = append(buf, a...)
    buf = append(buf, b...)
    return string(buf)
}
```

### Использование sync.Pool

!!! warning

    Про sync.Pool читайте в главе про параллельность.

```go
var bufPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func getBuffer() *bytes.Buffer {
    return bufPool.Get().(*bytes.Buffer)
}

func putBuffer(buf *bytes.Buffer) {
    buf.Reset()
    bufPool.Put(buf)
}
```

### Предварительное выделение памяти

#### Для срезов

```go
// Плохо
var items []string

// Хорошо
items := make([]string, 0, expectedSize)
```

#### Для map

```go
// Плохо
m := make(map[string]int)

// Хорошо
m := make(map[string]int, 100)
```

## Влияние GC на производительность

### Метрики для мониторинга

1. **Время пауз GC**: `runtime.ReadMemStats`
2. **Количество сборок**: `debug.GCStats`
3. **Размер кучи**: `runtime.MemStats.HeapAlloc`

### Пример мониторинга

```go
var m runtime.MemStats
runtime.ReadMemStats(&m)
fmt.Printf("HeapAlloc = %v MiB", m.HeapAlloc/1024/1024)
```

## Продвинутые техники

### Контроль за указателем

```go
//go:noinline
func createPointer() *int {
    x := 42
    return &x // Утечка указателя в кучу
}
```

### Анализ escape-анализа

```bash
go build -gcflags="-m" # показывает куда убегают переменные
```

### Ручной вызов GC

```go
runtime.GC() // Принудительный вызов сборщика
```

## Лучшие практики

1. **Избегайте глобальных переменных** — они никогда не очищаются
2. **Используйте value-методы** для небольших структур
3. **Ограничивайте время жизни объектов** — чем короче, тем лучше
4. **Профилируйте перед оптимизацией** — используйте pprof