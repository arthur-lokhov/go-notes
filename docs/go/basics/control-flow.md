# Управление потоком в Go

## For

### Стандартный цикл

```go
for i := 0; i < 10; i++ {
    sum += i
}
```

### Важное изменение в Go 1.21

!!! info

    В Go 1.21 было внесено важное изменение в работу циклов for. Теперь для переменной цикла на каждой итерации создается новая ссылка. Это влияет на использование переменных цикла в горутинах и замыканиях.

До Go 1.21:

```go
func main() {
    var funcs []func()
    for i := 0; i < 3; i++ {
        funcs = append(funcs, func() {
            fmt.Println(i) // Всегда печатало 3
        })
    }
    for _, f := range funcs {
        f()
    }
}
```

После Go 1.21:

```go
func main() {
    var funcs []func()
    for i := 0; i < 3; i++ {
        funcs = append(funcs, func() {
            fmt.Println(i) // Теперь печатает 0, 1, 2
        })
    }
    for _, f := range funcs {
        f()
    }
}
```

### Управляющие конструкции в циклах

#### break

!!! info

    Прерывает выполнение цикла и продолжает выполнение программы после цикла.

```go
for i := 0; i < 10; i++ {
    if i == 5 {
        break // Выход из цикла при i == 5
    }
    fmt.Println(i)
}
```

#### continue

!!! info

    Пропускает оставшуюся часть текущей итерации и переходит к следующей.

```go
for i := 0; i < 5; i++ {
    if i == 2 {
        continue // Пропускает печать числа 2
    }
    fmt.Println(i)
}
```

#### break с метками

!!! info

    Вы можете удивить знанием этого факта, его мало кто знает!

    Можно использовать break с метками для выхода из вложенных циклов

```go
OuterLoop:
    for i := 0; i < 5; i++ {
        for j := 0; j < 5; j++ {
            if i*j > 10 {
                break OuterLoop // Выход из обоих циклов
            }
            fmt.Printf("i=%d, j=%d\n", i, j)
        }
    }
```

## If

### Базовый синтаксис

```go
if x < 0 {
    return -x
}
```

### If с коротким оператором

```go
if v := math.Pow(x, n); v < lim {
    return v
}
```

### If-else

```go
if x < 0 {
    return -x
} else {
    return x
}
```

## Switch

### Базовый switch

```go
switch os := runtime.GOOS; os {
case "darwin":
    fmt.Println("OS X.")
case "linux":
    fmt.Println("Linux.")
default:
    fmt.Printf("%s.", os)
}
```

### Switch без условия

```go
switch {
case t.Hour() < 12:
    fmt.Println("Доброе утро!")
case t.Hour() < 17:
    fmt.Println("Добрый день!")
default:
    fmt.Println("Добрый вечер!")
}
```

### Switch с fallthrough

```go
switch 2 {
case 1:
    fmt.Println("1")
    fallthrough
case 2:
    fmt.Println("2")
    fallthrough
case 3:
    fmt.Println("3")
}
```

## Defer

### Порядок выполнения defer

!!! info

    Defer следует принципу LIFO (Last In, First Out).

```go
func main() {
    fmt.Println("start")
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
    fmt.Println("end")
}
// Выведет:
// start
// end
// 3
// 2
// 1
```

### Оценка аргументов в defer

!!! info

    Аргументы defer вычисляются немедленно, но функция выполняется перед возвратом.

```go
func main() {
    i := 0
    defer fmt.Println(i) // Выведет 0, не 1
    i++
}
```

### Defer и возвращаемые значения

!!! info
    Defer может изменять именованные возвращаемые значения:

```go
func example() (i int) {
    defer func() { i++ }() // Увеличивает i перед возвратом
    return 1 // Фактически вернёт 2
}
```

### Типичные применения defer

#### Закрытие файлов

```go
f, err := os.Open("file.txt")
if err != nil {
    return err
}
defer f.Close() // Гарантированное закрытие файла
```

#### Освобождение мьютексов

```go
mu.Lock()
defer mu.Unlock() // Гарантированное освобождение блокировки
```

#### Восстановление после паники

```go
defer func() {
    if r := recover(); r != nil {
        fmt.Println("Recovered from:", r)
    }
}()
```

## Часто задаваемые вопросы

### **В**: Как изменения в Go 1.21 влияют на существующий код?

- Старый код может работать по-другому в горутинах и замыканиях
- Переменные цикла теперь имеют отдельную область видимости на каждой итерации
- Может потребоваться пересмотр кода, использующего переменные цикла в замыканиях

### **В**: Когда использовать break с метками?

- При необходимости выхода из вложенных циклов
- Когда нужно прервать выполнение конкретного внешнего цикла
- В сложных алгоритмах с множественными уровнями вложенности

### **В**: В чем особенность fallthrough в Go?

- Выполняется безусловно
- Должен быть последним оператором в case
- Нельзя использовать в последнем case
- Передает управление следующему case независимо от его условия

### **В**: Какие есть особенности работы defer?

- Выполняется в порядке LIFO
- Аргументы вычисляются при объявлении
- Может изменять именованные возвращаемые значения
- Часто используется для освобождения ресурсов
