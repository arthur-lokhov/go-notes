# Методы в Go

## Основы методов

### Объявление метода

```go
type Vertex struct {
    X, Y float64
}

func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```

### Методы для не-структурных типов

```go
type MyFloat float64

func (f MyFloat) Abs() float64 {
    if f < 0 {
        return float64(-f)
    }
    return float64(f)
}
```

## Указатели и методы

### Методы с указателем в receiver

```go
func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}
```

### Автоматическое разыменование

```go
v := Vertex{3, 4}
v.Scale(2) // Go автоматически интерпретирует как (&v).Scale(2)
```

## Методы и интерфейсы

### Реализация интерфейса

```go
type Abser interface {
    Abs() float64
}

// Vertex автоматически реализует Abser
func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```

### Выбор между указателем и значением

```go
// Метод с receiver-значением
func (v Vertex) Method() float64 {
    return v.X
}

// Метод с receiver-указателем
func (v *Vertex) Method() float64 {
    return v.X
}
```

## Часто задаваемые вопросы

### **В**: Когда использовать указатель в receiver?

- Когда метод модифицирует receiver
- Для избежания копирования больших структур
- Когда все методы типа должны иметь одинаковый тип receiver

### **В**: В чем разница между методами и функциями?

- Методы имеют receiver
- Методы могут быть определены только для типов в том же пакете
- Методы помогают в реализации интерфейсов

### **В**: Как работает автоматическое разыменование?

- Go автоматически преобразует v.Method() в (&v).Method()
- Работает только для методов
- Не работает в обратную сторону для указателей

### **В**: Когда использовать методы вместо функций?

- Когда функциональность тесно связана с типом
- При реализации интерфейсов
- Когда нужно модифицировать состояние объекта
