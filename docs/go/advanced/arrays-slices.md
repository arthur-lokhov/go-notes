# Массивы и Слайсы в Go

## Массивы

### Внутреннее устройство массивов

!!! info

    Массив в Go - это непрерывный участок памяти фиксированной длины, содержащий элементы одного типа.

```go
// Массив из 5 целых чисел
var arr [5]int

// Массив из 3 строк с инициализацией
names := [3]string{"Alice", "Bob", "Charlie"}

// Массив с автоматическим определением размера
numbers := [...]int{1, 2, 3, 4, 5}
```

#### Особенности массивов
1. Размер является частью типа:
```go
var a [5]int
var b [6]int
// a и b имеют разные типы!
```

2. Передача по значению:
```go
func modify(arr [5]int) {
    arr[0] = 100 // Изменения не затронут оригинальный массив
}
```

### Производительность массивов

Преимущества:

- Быстрый доступ к элементам (O(1))
- Нет дополнительных накладных расходов
- Кэш-эффективность из-за непрерывности памяти

Недостатки:

- Фиксированный размер
- Копирование при передаче в функции
- Невозможность изменения размера

## Слайсы

### Внутреннее устройство слайсов

!!! info

    Слайс - это структура данных, состоящая из трёх полей:
    
    - Указатель на базовый массив
    - Длина (len)
    - Емкость (cap)

```go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

### Создание и инициализация слайсов

#### 1. Нулевой слайс

```go
var s []int // s == nil, len(s) == 0, cap(s) == 0
```

!!! info "Важно"
    Нулевой слайс (nil slice) отличается от пустого слайса!
    ```go
    var s []int          // nil slice: s == nil
    s := []int{}        // empty slice: s != nil
    s := make([]int, 0) // empty slice: s != nil
    ```

#### 2. Создание через make

```go
// make([]T, length, capacity)
s := make([]int, 2, 5)
```

!!! example "Визуализация make([]int, 2, 5)"
    ```
    Базовый массив: [0, 0, ?, ?, ?]
                     │  │  │  │  │
                     └──┴──┘  │  │
                        │     │  │
                      len=2   │  │
                             cap=5
    ```

- `length` (2) - определяет количество инициализированных элементов
  - Все эти элементы инициализируются нулевым значением для типа
  - Для int это 0
  - Для string это ""
  - Для указателей, слайсов, map это nil
- `capacity` (5) - определяет размер базового массива
  - Элементы после length не инициализируются
  - Эта память зарезервирована для будущего роста через append

Примеры инициализации для разных типов:
```go
// Для целых чисел
s := make([]int, 2, 5)     // [0, 0], len=2, cap=5

// Для строк
s := make([]string, 2, 5)  // ["", ""], len=2, cap=5

// Для булевых значений
s := make([]bool, 2, 5)    // [false, false], len=2, cap=5

// Для структур
type Person struct {
    Name string
    Age  int
}
s := make([]Person, 2, 5)  // [{Name:"" Age:0}, {Name:"" Age:0}], len=2, cap=5

// Для указателей
s := make([]*int, 2, 5)    // [nil, nil], len=2, cap=5
```

#### 3. Доступ к элементам

```go
s := make([]int, 2, 5)
fmt.Println(s[0], s[1])    // 0 0 - доступ к инициализированным элементам
fmt.Println(s[2])          // panic: index out of range - нельзя обращаться к элементам за пределами length
```

#### 4. Расширение слайса

```go
s := make([]int, 2, 5)     // [0, 0], len=2, cap=5
s = s[:3]                  // [0, 0, 0], len=3, cap=5 - расширение в пределах capacity
s = s[:5]                  // [0, 0, 0, 0, 0], len=5, cap=5
s = s[:6]                  // panic: slice bounds out of range - нельзя расширить больше capacity
```

#### 5. Append и инициализация

```go
s := make([]int, 2, 5)     // [0, 0], len=2, cap=5
s = append(s, 1)           // [0, 0, 1], len=3, cap=5
```

!!! warning "Важно помнить"
    1. Элементы в диапазоне [0:length] всегда инициализированы нулевыми значениями
    2. Элементы в диапазоне [length:capacity] не инициализированы и не доступны напрямую
    3. При расширении слайса через s[:n] новые элементы инициализируются нулевыми значениями
    4. При append новые элементы получают значения из аргументов append

#### 6. Сравнение с nil

```go
var s []int               // s == nil
s = make([]int, 0)       // s != nil
s = make([]int, 0, 10)   // s != nil
s = []int{}              // s != nil
```

!!! tip "Совет"
    При проверке слайса на пустоту лучше использовать `len(s) == 0`, а не сравнение с `nil`,
    так как пустой слайс может быть как nil, так и не nil.

### Оптимизации и особенности

#### 1. Рост слайса

!!! info

    Рост слайса крайне часто спрашивают на собесах!

При добавлении элементов через append, если текущей емкости недостаточно:

1. Создается новый массив с большей емкостью
2. Копируются все элементы
3. Обновляется указатель на базовый массив

```go
// Алгоритм роста (упрощенно):
if cap < 1024 {
    newcap = cap * 2
} else {
    newcap = cap * 1.25
}
```

#### 2. Разделение базового массива

```go
original := []int{1, 2, 3, 4, 5}
slice1 := original[1:3]
slice2 := original[2:4]

// slice1 и slice2 разделяют память с original
slice1[1] = 10 // Изменит также original[2] и slice2[0]
```

#### 3. Копирование слайсов

!!! info

    Крайне важно знать это, чтобы не ошибиться в работе с слайсами.

```go
// Безопасное копирование
dst := make([]int, len(src))
copy(dst, src)

// или
dst := append([]int(nil), src...)
```

### Практические примеры

#### 1. Эффективное добавление элементов

```go
// Предварительное выделение памяти
s := make([]int, 0, expectedSize)

// Добавление элементов
s = append(s, newElement)
```

#### 2. Удаление элементов

```go
// Удаление с сохранением порядка
func remove(slice []int, i int) []int {
    copy(slice[i:], slice[i+1:])
    return slice[:len(slice)-1]
}

// Удаление без сохранения порядка (быстрее)
func fastRemove(slice []int, i int) []int {
    slice[i] = slice[len(slice)-1]
    return slice[:len(slice)-1]
}
```

#### 3. Фильтрация элементов

```go
// Фильтрация с переиспользованием памяти
func filter(s []int, fn func(int) bool) []int {
    n := 0
    for _, v := range s {
        if fn(v) {
            s[n] = v
            n++
        }
    }
    return s[:n]
}
```

## Частые вопросы

### **В**: В чем разница между len и cap?

- `len` - текущее количество элементов в слайсе
- `cap` - максимальное количество элементов, которое может содержать слайс без перераспределения памяти
- `cap` всегда >= `len`

### **В**: Почему append может вернуть новый слайс?

- Если текущей емкости недостаточно, создается новый базовый массив
- Старый массив остается в памяти до сборки мусора
- Новый слайс указывает на новый массив

### **В**: Как избежать утечек памяти при работе со слайсами?

1. Не храните маленькие слайсы большого массива
2. Используйте copy() для создания независимых слайсов
3. При обработке больших файлов используйте bufio.Scanner
4. Освобождайте ссылки на ненужные элементы

### **В**: Когда использовать массивы вместо слайсов?

1. Когда размер фиксирован и известен заранее
2. В производительно-критичном коде
3. Когда важна кэш-локальность
4. В системном программировании

### **В**: Как работает append с точки зрения производительности?

1. Если есть место в cap - O(1)
2. Если нужно перевыделение - O(n)
3. Амортизированная сложность - O(1)
4. При известном размере лучше использовать make с указанием cap
