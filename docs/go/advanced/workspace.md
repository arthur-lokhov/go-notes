---
title: Рабочие пространства
---

# 📦 `go.work`: Рабочие пространства

## 📘 Что такое `go.work`

!!! note "`go.work` - это механизм из Go 1.18+, который помогает организовать работу с несколькими Go-модулями в рамках одной кодовой базы (например, монорепозитория)."

Он говорит компилятору и инструментам Go использовать локальные пути к модулям, указанные в директиве `use`, вместо версий из прокси или `go.mod`.

Это удобно:

- при разработке библиотек в рамках одного репозитория,
- при правке зависимостей без публикации новых версий,
- для монореп,
- для работы в команде (без replace-хаоса).

---

## 🧩 Пример `go.work`

```gowork
go 1.22

use (
    ./app
    ../libs/common
    ../libs/logger
)
```

Go будет искать модули по указанным путям:

- `./app`,
- `../libs/common`,
- `../libs/logger`.

Если один из этих путей соответствует зависимости из `go.mod` какого-либо модуля в `go.work` — он будет использовать локальную версию, а не ту, что указана в `require`.

---

## ⚙️ Команды `go work`

| Команда               | Назначение                                                               |
| --------------------- | ------------------------------------------------------------------------ |
| `go work init [dirs]` | Создает файл `go.work` с указанными путями.                              |
| `go work use [dirs]`  | Добавляет директории с модулями в `use`-секцию.                          |
| `go work edit`        | Программное редактирование (добавление, удаление путей, изменение `go`). |
| `go work sync`        | Синхронизирует версии зависимостей всех модулей на единую.               |
| `go work vendor`      | Создает `vendor/` для всего рабочего пространства.                       |

Примеры команд:

```bash
go work init ./main ./libs/mylib
go work use ../auth ../billing
go work sync
go work edit -dropuse ./libs/logger
```

---

## 🔄 Что делает go work sync на самом деле

Команда `go work sync`:

- 🔍 Сканирует все модули, перечисленные в `use`, и находит пересечения зависимостей,
- 🧮 Использует алгоритм минимального выбора версии, чтобы унифицировать зависимости между модулями,
- 🔗 Может внести изменения в `go.mod`-файлы всех подключённых модулей, обновив версии зависимостей, чтобы они совпадали,
- 💡 Это аналог ручной правки `go.mod`, но централизованно.

!!! info "Алгоритм минимального выбора версии"

    Про минимальный выбор версии (**MVS**) рассказывается в главе о [модулях](./modules.md).

---

## 🧠 Как Go выбирает версию модуля в `go.work`

Если в `go.mod` проекта указано:

```gomod
require github.com/acme/common v1.2.3
```

а в файле `go.work` прописан путь к локальной копии этой библиотеки:

```gowork
use (
    ../libs/common
)
```

и внутри `../libs/common/go.mod` указан тот же самый модульный путь:

```gomod
module github.com/acme/common
```

то Go понимает: Это одна и та же библиотека, просто сейчас она лежит локально, и мне нужно использовать именно эту локальную версию, а не загружать её через proxy.

!!! note "Данное поведение полностью аналогично ручной замене с помощью `replace`"
    
    ```gomod
    replace github.com/acme/common => ../libs/common
    ```

---

## 🧮 Что, если версии модулей расходятся

Если модули в `go.work` зависят от разных версий одной библиотеки, например:

`app/go.mod`:

```gomod
require github.com/some/dependency v1.2.0
```

`libs/common/go.mod`:

```gomod
require github.com/some/dependency v1.1.0
```

!!! note "То согласно MVS выбирается наибольшая требуемая версия - `v1.2.0`."

Из-за этого важно контроллировать зависимости ведь между `v1.1.0` и `v1.2.0` может быть несовместимость версий.

---

## 🔄 `go.work` vs `replace`

| 🔧 **Критерий**                    | 🔁 **`replace`**                        | 🧩 **`go.work`**                                              |
| ---------------------------------- | --------------------------------------- | ------------------------------------------------------------- |
| 📍 **Где используется**            | В `go.mod` каждого модуля               | В одном `go.work` для всего рабочего пространства             |
| 📦 **Область действия**            | Только в текущем модуле                 | Все модули, указанные в `use`                                 |
| ✍️ **Настройка**                   | Ручное добавление в каждый `go.mod`     | Один раз через `go work use`, можно рекурсивно                |
| 🧑‍💻 **Лучше всего подходит для** | Временные подмены, forking зависимостей | Моно-реп, командная разработка, внутренняя разработка пакетов |
| ⚠️ **Ограничения и минусы**        | Повторяется, легко забыть обновить      | Требует Go 1.18+, не работает без `go.work`                   |

---

## 🧪 Комбинация go.work и replace

Вы можете использовать `go.work` вместе с `replace` внутри отдельных `go.mod`.

```gowork
go 1.22

use (
    ./app
    ./libs/common
)
```

В `app/go.mod`:

```gomod
require github.com/ext/foo v1.2.0

replace github.com/ext/foo => ../forks/foo
```

!!! warning "Если `replace` и `use` указывают на одно и то же — `use` из `go.work` имеет приоритет."

---

## 📂 Пример структуры рабочего пространства

Структура проекта:

```bash
project-root/
├── go.work
├── app/
│   └── go.mod (require github.com/acme/common v1.0.0)
├── libs/
│   └── common/
│       └── go.mod (module github.com/acme/common)
```

Файл `go.work`:

```gowork
go 1.22

use (
    ./app
    ./libs/common
)
```

Теперь `app` использует локальную версию `github.com/acme/common`, даже если в `go.mod` указана другая версия.

---

## 🚧 Ограничения и особенности

- 📁 Все пути в `use` должны указывать на директории с `go.mod`.
- 🧪 У вас не должно быть конфликта путей модулей — Go выберет первый, что найден.
- 🧱 `go.work` не публикуется и не влияет на `go.mod` — он локален, аналог `.tool-versions` или `.nvmrc`.
- 🤝 Хорошо поддерживается GoLand, gopls, VSCode (автоматически подхватывается), но проект должен быть открыт в корне с файлом `go.work`.
- 🔁 Работает вместе с `replace`, но `use` в `go.work` имеет приоритет.
- ❌ Не работает в Go до версии **1.18**.
- 🗃 Использование `go.work vendor` требует ручного управления `vendor`.
- 🧾 При использовании `go.work`, Go создает файл `go.work.sum`, аналогичный `go.sum`, но для всех подключённых модулей.

---

## 📌 Типовые сценарии

### 🧱 Моно-репозиторий

```bash
repo/
├── go.work
├── services/
│   ├── service-a/
│   └── service-b/
├── libs/
│   ├── common/
│   └── logger/
```

```gowork
use (
    ./services/service-a
    ./services/service-b
    ./libs/common
    ./libs/logger
)
```

### 🧍 Потребитель

```bash
cd consumer/
go work init . ../my-lib
```

Теперь можно править `../my-lib`, и `consumer` будет видеть актуальные изменения.
