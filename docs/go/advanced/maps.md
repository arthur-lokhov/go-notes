# Map в Go

!!! info

    Map в Go - это хеш-таблица, реализующая ассоциативный массив (словарь). Она позволяет хранить пары "ключ-значение", где ключи уникальны.

## Внутреннее устройство

### До Go 1.24: классическая хеш-таблица (hmap)

#### Базовая структура hmap

```go
type hmap struct {
    count     int    // количество элементов в map
    flags     uint8  // флаги состояния
    B         uint8  // логарифм количества бакетов (2^B)
    noverflow uint16 // количество переполненных бакетов
    hash0     uint32 // seed для хеш-функции
    
    buckets    unsafe.Pointer // массив бакетов
    oldbuckets unsafe.Pointer // старые бакеты при росте
    nevacuate  uintptr        // прогресс эвакуации
    
    extra *mapextra // дополнительные поля
}
```

#### Структура бакета (bucket)

```go
type bmap struct {
    tophash [8]uint8    // верхние биты хешей ключей
    keys    [8]keytype  // массив ключей
    values  [8]valuetype // массив значений
    overflow *bmap       // указатель на следующий бакет при коллизии
}
```

#### Как работала hmap

1. **Хеширование ключа**: ключ хешируется с использованием hash0 для рандомизации и используется для определения бакета.
2. **Поиск бакета**: Вычисляется `bucket = hash & (2^B - 1)` и если идет рост таблицы, проверяются `oldbuckets`.
3. **Поиск в бакете**: Сравниваются `tophash` (первые 8 бит хеша), при совпадении `tophash` сравнивается полный ключ. Если бакет заполнен - проверяется `overflow-цепочка`.
4. **Рост таблицы**: При переполнении происходит увеличение в 2 раза (B++), Данные постепенно переносятся из oldbuckets в новые buckets.

#### Проблемы hmap

- Высокий overhead памяти из-за overflow-бакетов
- Неэффективное использование кеша процессора
- Сложная логика постепенного роста

### После Go 1.24: Swiss Table

#### Основные изменения

1. **Новая структура хранения**: Отдельные массивы для метаданных и данных.
2. **Улучшенная локальность**: Метаданные хранятся в компактном виде, Лучшее использование кеш-линий процессора.
3. **Оптимизированные коллизии**: Уменьшение количества проб при коллизиях, Более эффективный поиск.

#### Ключевые преимущества Swiss Table

1. **Экономия памяти**: Уменьшение накладных расходов на 20-30%.
2. **Ускорение операций**: До 30% быстрее поиск, Уменьшение задержек при вставке.
3. **Улучшенная масштабируемость**: Более предсказуемая производительность при росте, Меньшие пиковые затраты памяти.

## Операции с map

### Инициализация

Map можно инициализировать несколькими способами:

```go
// Нулевой map (nil)
var m map[string]int

// Пустой map
m = make(map[string]int)

// С начальной емкостью
m = make(map[string]int, 100)

// Литерал
m := map[string]int{
    "one": 1,
    "two": 2,
}
```

### Основные операции

```go
// Добавление/обновление
m["key"] = value

// Получение
value, exists := m["key"]

// Удаление
delete(m, "key")

// Итерация
for key, value := range m {
    // порядок итерации не гарантирован
}
```

### Конкурентный доступ

Map не является потокобезопасным, поэтому для безопасного доступа в многопоточных приложениях используйте мьютексы или `sync.Map`.

```go
// Безопасная map для конкурентного доступа
type ConcurrentMap struct {
    sync.RWMutex
    data map[string]int
}

func (m *ConcurrentMap) Set(key string, value int) {
    m.Lock()
    defer m.Unlock()
    m.data[key] = value
}
```

## Производительность

### Сложность операций
- Доступ: O(1) в среднем
- Вставка: O(1) в среднем
- Удаление: O(1) в среднем
- Поиск: O(1) в среднем

### Рекомендации по производительности

```go
// Предварительное выделение памяти
m := make(map[string]int, expectedSize)

// Избегайте лишних поисков
if value, ok := m["key"]; ok {
    // используем value
}

// Удаление больших map
// Лучше создать новый, чем удалять много элементов
oldMap = nil
newMap = make(map[string]int)
```

## Частые вопросы

### **В**: Почему map не является concurrent safe?

- Map не потокобезопасен по дизайну для производительности.
- При конкурентной записи может возникнуть race condition.
- Используйте `sync.Map` или мьютексы для конкурентного доступа.

### **В**: Как определить размер map?

```go
// Получение количества элементов
size := len(m)

// Емкость не доступна
// cap(m) - не работает
```

### **В**: Можно ли сравнивать map?

- Map можно сравнивать только с nil.
- Прямое сравнение двух map невозможно.
- Нужно сравнивать поэлементно.

```go
// Сравнение map
func equal(m1, m2 map[string]int) bool {
    if len(m1) != len(m2) {
        return false
    }
    for k, v1 := range m1 {
        if v2, ok := m2[k]; !ok || v1 != v2 {
            return false
        }
    }
    return true
}
```

### **В**: Какие типы могут быть ключами?

- Любые сравнимые типы (comparable).
- Числа, строки, указатели, интерфейсы.
- Структуры и массивы, содержащие только сравнимые типы.
- НЕ могут быть: слайсы, map, функции.

### **В**: Как работает удаление элементов?

1. `delete` не уменьшает размер выделенной памяти.
2. Память освобождается только при создании нового map.
3. При массовом удалении лучше создать новый map.
